# 第一章 Java基础入门

## 1 概述

Java是什么：Java是一门面向对象的程序设计语言

## 2 历史（了解）

## 3 平台

* J2SE(Java 2 Platform Standard Edition)标准版

  是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发
* J2ME(Java 2 Platform Micro Edition)小型版

  是为开发电子消费产品和嵌入式设备提供的解决方案
* J2EE(Java 2 Platform Enterprise Edition)企业版

  是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 

## 4 JDK

1. 环境变量

   JAVA_HOME：指定JDK的安装目录

   PATH：指定命令搜索路径，方便在命令行窗口的任意目录启动程序

   CLASSPATH：指定将来要运行或加载的class文件的所在路径

2. JDK结构

   JRE：JVM+类库

   JDK：JRE+开发工具

3. JDK目录

   bin：开发工具
   include：头文件
   db：自带的小型数据库
   lib：java类库
   jre：java运行环境
   src.zip：java源代码

## 5 Java特点

- 跨平台
- 开源
- 安全
- 易学易用（面向对象编程、无指针GC进行内存管理、强大的API...）

## 6 入门案例

Java程序开发流程：编辑-->编译-->运行

- 编辑 Hello.java
- javac Hello.java -->Hello.class
- java Hello

源文件：

- 以.java结尾
- 一个源文件中只能包含一个public class，文件名要与public class名相同
- 唯一的入口方法main，格式固定public static void main(String[] args)

## 7 跨平台原理

跨平台实现：字节码+虚拟机

- 字节码所有平台通用
- 虚拟机每个平台安装对应版本

## 8 常用命令

- javac：编译命令

  javac -d classes src/Hello.java

- java：运行命令

  java -cp classes com.briup.chap01.Hello

- javadoc：生成API文档命令

- javap：字节码反解析命令

- jar：打包命令

## 9 package

包的作用：

- 解决命名冲突问题
- 类的分类管理

类的全限定名：包名+类名

注意事项：

- package语句必须是程序的第一条可执行的代码
- package语句在一个Java文件中最多只能有一个
- 程序中可以不用package，表示无包名
- 包其实就是文件夹，一般是公司域名倒着写

常用的包：

- java.lang：最常用的一个包，默认导入
- java.io：输入输出流的操作
- java.net：网络编程
- java.util：一些常用工具类

## 10 API文档

![image-20240909094817373](image\image-20240909094817373.png)

## 11 扩展内容

1.  JVM虚拟机：模拟Java的运行环境

   ![image-20240909102127691](image\image-20240909102127691.png)



2. 字节码验证

   ![image-20240909102738038](image\image-20240909102738038.png)

主要验证内容：

- 检查当前class文件的版本和JVM的版本是否兼容
- 检查当前代码是否会破坏系统的完整性
- 检查当前代码是否有栈溢出的情况
- 检查当前代码中的参数类型是否正确
- 检查当前代码中的类型转换操作是否正确

字节码结构：

![image-20240909104032011](image\image-20240909104032011.png)

JIT（Just In Time）即时编译：把Java中的热点代码直接编译成计算机可以运行的二进制指令，提高运行效率。

3. 垃圾回收器（Garbage Collection，GC）

   JVM中的后台线程，用于内存管理

   程序员建议进行垃圾回收：

   ```java
   java.lang.System.gc();
   java.lang.Runtime.gc();
   ```

   最终要根据GC的具体算法和当前内存的使用情况来确定。



# 第二章 标识符、常量、变量、类型转换

## 1 注释

注释分类：

- 单行注释
  一般用来对变量做简单描述
- 多行注释
  一般用来描述类、方法、算法
- 文档注释
  使用位置类似多行注释，可以产生API文档

使用注意：

- 单行注释可以嵌套，多行注释和文档注释不能嵌套
- 注释用来增加程序可读性，只在源文件中有效，编译成字节码后，全部剔除

`保证程序正确性的前提下，可读性放在第一位！`

- 添加注释
- 程序编写先整体，后细节（使用方法）；单个方法代码尽量不要超过100行

## 2 关键字

被Java语言赋予特定含义的单词

![image-20240909113116628](image\image-20240909113116628.png)

## 3 标识符

在Java中给类、方法、变量起的名字

Java中命名规则：

- 以字母、_、$开始
- 可以包含字母、数字、_、$
- 大小写敏感
- 无长度限制
- 不能使用java中的关键字和保留字

命名约定：

- 见名知意
- 驼峰命名法：类、方法、变量的名字
- 常量单词全部大写用_分割

## 4 常量

在程序运行过程中，其值不可以发生改变的量

常量分类：

- 字面值常量
- 自定义常量 (面向对象部分讲解)

字面值常量分类：

- 字符串常量	用双引号括起来的内容
- 整数常量	所有整数
- 小数常量	所有小数
- 字符常量	用单引号括起来的内容，里面只能放单个数字、字母或符号
- 布尔常量	较为特殊，只有true和false
- 空常量		null

## 5 变量

在程序执行的过程中，在某个范围内其值可以发生改变的量

数据类型 变量名 = 数据值;

变量名：就是一个标识符，用来标识内存上的一块空间
数据值：即变量值，该值会存储到变量名标识的那块空间中

变量小结：

- 变量名是标识符中的一种，用来标识一块内存区域
- 变量定义后没有赋初值，不能直接使用，编译报错
- 变量值的类型应该跟变量的类型一致



## 6 数据类型

Java语言是强类型语言，每一种数据都定义了明确的数据类型，不同类型变量占用内存大小不同，取值范围不同。

Java数据类型可以分为两大类：

- 基本数据类型（本章重点讲解）
  整形 byte、short、int、long
  浮点型 float、double
  字符类型 char
  布尔类型 boolean
- 引用数据类型（面向对象部分补充）
  数组
  类
  接口

### 6.2 基本类型

分为4大类8小种，且每种表示范围不同。

![image-20240910130123788](D:\video\zhongbei1\image\image-20240910130123788.png)

**浮点型：**

IEEE754标准：

![image-20240909193114162](D:\video\zhongbei1\image\image-20240909193114162.png)

**字符型**
char ，用于表示一个16位的Unicode字符（包括中文汉字），其类型值用一般 '' 括起来单个字符，范围是0-65535。



### 6.3 进制基础

不同进制形式：

- 二进制 0b或0B开头，由0和1组成
- 八进制 0开头，由0、1...6、7组成
- 十进制 常见整数，由0、1...8、9组成
- 十六进制 0x或0X开头，由0、1...8、9、a、b、c、d、e、f组成，大小写不区分

不论什么类型的数据值，在计算机的底层存储时，统一按照二进制形式存储！



### 6.4 进制转换

1. 任意进制转换为10进制

   转换方式：
   `结果值 = 系数*基数的权次幂相加`
   系数：每一位上的数据
   基数：X进制，基数就是X
   权：最右边那位对应0，每左移一位加1

2. 十进制转换为其他进制

   除积倒取余

3. 十进制到二进制的快速转换

   对于不太大的正整数，我们可以采用一种快捷的方式（8421码）来获取其2进制形式。

   运算步骤：

   拆解正整数，将其分解为2的指数倍相加
   找出2的指数倍 对应的 二进制1
   根据变量类型确定占用的字节数及比特位，组合得到最终的二进制形式

4. 二进制转换为8、16进制

   **2进制转化为8进制：**
   从最低位开始，每3位分一组，不足3位的话高位补0
   将得到的数字组合到一起，最前面以0开头

   **2进制转换为16进制：**
   从最低位开始，每4位分一组，不足4位的话高位补0
   将得到的数字组合到一起，最前面以0x开头

### 6.5 字符类型

char类型用于表示一个占2个字节（16位）的Unicode字符（包括中文汉字），其是基本数据类型，取值范围为0-65535。

一般情况下，我们使用单引号括起来单个字符来表示字符值，但也可以用数字值表示。

**字符编码定义了字符与字节之间的转换关系。**Java 表示内部字符采用 Unicode 字符集。
Unicode 是一种国际字符集，旨在为世界上几乎所有的字符提供唯一的数字编码，它定义了每个字符与一个唯一的数字值之间的映射关系，这个数字值称为 Unicode 码点（code point）。

每一种字符编码，都有一个与之对应字符编码表，其中包含了每个字符对应的码点值。

实际开发时，我们用码点给字符变量赋值的情况很少，大多数情况下还是使用常规字符赋值。

转义字符是一种特殊的字符序列，用于表示一些特殊字符或具有特殊含义的字符。



### 6.6 原反补码

1. 原码
   就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。

2. 反码
   正数的反码与其原码相同

   负数的反码，在原码的基础上，保留符号位，其他位逐位取反

3. 补码
   正数的补码与其原码相同
   负数的补码是在其反码的末位加1

数据在计算机底层进行存储或运算，以补码方式进行！



课堂练习：-123原反补

123 = 127 - 4 或 64 + 32 + 16 + 8 + 0 + 2 + 1
0b 0111 1011

原码：1000... 0111 1011

反码：1111... 1000 0100

补码： 1111... 1000 0101



## 7 常量补充

整数常量默认类型int；小数常量默认类型double；字符常量默认类型char。

整形字面值，不论是二进制、八进制还是十进制、十六进制，默认都是int类型常量。

long、float等类型的常量书写：

- 整形数后面加'L'或'l'，就表示long类型字面值常量
- 小数后面加'F'或'f'，就表示float类型字面值常量

## 8 类型转换

![image-20240910115419584](D:\video\zhongbei1\image\image-20240910115419584.png)

- 隐式类型转换：小数据类型值或变量可以直接赋值给大类型变量

  byte、short、char类型的数据在进行算术运算时，会先自动提升为int，然后再进行运算

  其他类型相互运算时，表示范围小的会自动提升为范围大的，然后再运算

- 显式类型转换：大类型数据赋值给小类型变量，编译会报错，此时必须通过强制类型转换实现。

  `数据类型 变量名 = (目标数据类型)(数值或变量或表达式);`

整形常量优化机制：
使用整形字面值常量(默认int类型)赋值给其他类型（byte、char、short）变量时，系统会先判断该字面值是否超出赋值类型的取值范围，如果没有超过范围则赋值成功，如果超出则赋值失败。

注意事项：
常量优化机制只适用于常量，如果是变量，则不可以
该优化机制只针对int类型常量，对于long、float、double等常量，则不可以

课堂练习：(int)(char)(byte)-1

111111111111111111111111
1111,1111  byte
1111,1111,1111,1111  char
0000,0000,0000,0000,1111,1111,1111,1111 int
类型转换时，有符号数采用符号扩展，无符号数采用0扩展



# 第三章 操作符、流程控制

## 1 操作符

操作符：对字面值常量或变量进行操作的符号，也称 运算符 。
表达式：用操作符把字面值常量或变量连接起来的式子。

### 1.1 运算符分类

操作符分类：

- 算术运算符
- 赋值运算符
- 比较|关系|条件 运算符
- 逻辑运算符
- 位运算符
- 三目运算符

### 1.2 算术运算符

![image-20240911123920743](D:\video\zhongbei1\image\image-20240911123920743.png)

求余运算，结果符号只跟左操作数的符号有关。

+除了可以作为加法运算符，也可以作为字符串连接符。字符串 + 其他任意类型数据，得到的结果都是字符串。

操作符重载

变量名++：后增量，作为表达式使用，表示将变量原有值作为表达式的值，再对变量自增

 ++变量名：前增量，作为表达式使用，表示先对变量自增，自增后的值作为表达式的值

自增自减运算底层会自动进行类型转换。

### 1.3 赋值运算符

![image-20240911123949618](D:\video\zhongbei1\image\image-20240911123949618.png)

左值 = 右值，左值一定是变量，右值可以是变量也可以是常量。

复合赋值运算符，底层会隐式地将右值类型转换为左值类型。

### 1.4 比较运算符

![image-20240911124013837](D:\video\zhongbei1\image\image-20240911124013837.png)

返回boolean类型

Scanner 类是Java提供好的API，可以接收用户从键盘中的输入。

### 1.5 逻辑运算符

![image-20240911124051540](D:\video\zhongbei1\image\image-20240911124051540.png)

&& 和 || 有逻辑短路功能，比如&&，第一个条件为假，后面条件就不用运算了，整体表达式的结果为假。

& 和 | 没有逻辑短路功能。

### 1.6 移位运算符

![image-20240911124122201](D:\video\zhongbei1\image\image-20240911124122201.png)

如果要进行移位操作，则需要先获取操作数的二进制形式（补码），然后按位进行操作。

\>>：算数右移、带符号右移，高位补符号位

\>>>：逻辑右移、不带符号右移，高位补0

<<：左移，低位补0，相当于乘以2

数值左移n位(移动后将超出数值最高位)，等同 数值 << (n%当前值所属类型所占比特位)

### 1.7 位运算符

![image-20240911123834422](D:\video\zhongbei1\image\image-20240911123834422.png)

一个数 异或 另一个数 2次，结果是自己。

| 可以用来将位置1

& 可以用来将位清0

### 1.8 三目运算符

`(关系表达式) ? 表达式1 : 表达式2;`

关系表达式成立，返回表达式1，否则返回表达式2。

运算符优先级：

![image-20240911125640090](D:\video\zhongbei1\image\image-20240911125640090.png)



## 2 流程控制

程序中，需要执行的代码，其结构主要分为以下三种：

- 顺序结构
- 分支结构
  if语句、switch分支语句
- 循环结构
  for循环、while循环、do while循环

### 2.1 顺序结构

顺序结构是最基本的流程控制，代码从上到下顺序执行。

### 2.2 if判断

**语法：**

if (关系表达式1) {
  语句体1;
}
else if (关系表达式2) {
  语句体2;
} …
else {
  //else代码;
}

**执行流程：**

1. 首先计算 关系表达式1 的值
2. 如果表达式1的值为true，就执行语句体1；如果值为false就计算关系表达式2的值
3. 如果表达式2的值为true，就执行语句体2；如果值为false就计算关系表达式3的值
4. ....
5. 如果上面关系表达式结果都为false，就执行else代码
6. 如果中间有任何一个关系表达式为true，那么执行完对应的代码语句之后，整个if-elseif-else退出

**注意事项：**
从上到下依次判断，有一个判断为true执行了代码，那么后续判断都不再执行，if语句结束；如果判断都为false，则执行else语句代码。

如果有多个关系表达式判断，前面的判断为false会隐式地将其反向条件传递给后面的关系表达式进行判断。

### 2.3 switch分支

**语法：**

switch (表达式) { 
case 值1: //分支入口
	语句体1;
	break;
case 值2: //分支入口
	语句体2;
	break;
...
default:
	语句体n+1;
	break;
}
//后续语句

![image-20240912101624370](D:\video\zhongbei1\image\image-20240912101624370.png)

执行流程：

![image-20240912101655115](D:\video\zhongbei1\image\image-20240912101655115.png)



**注意事项：**

switch语句可以成功匹配多个分支，多个分支的语句体都可以被执行，除非遇到break跳出整个switch语句。

如果每个swich分支都不加break，则第一个匹配的case语句体及其后所有的语句体都会被执行（击穿）。

### 2.4 for循环

**语法：**

for (初始化语句1; 条件判断语句2; 条件控制语句4) {
		循环体语句3;
}

**执行流程：**

1. 执行初始化语句1
2. 执行条件判断语句2，看其结果是true还是false
如果是false，循环结束
如果是true，执行循环体语句3
3. 执行条件控制语句4
4. 回到步骤2继续执行

**注意事项：**

初始化变量和改变变量的值，是可以写到其他地方的。

```java
int i = 0;
  for(;i < 5;){
    System.out.println("hello world");
    i++;
 }
```

死循环经常应用在网络服务器端编程。

```java
for(;;) {
  System.out.println("hello world");
}
```

### 2.5 while循环

**语法：**

初始化语句1;
while (条件判断语句2) {
		循环体语句3;

​		条件控制语句4;
}

**执行流程：**

1. 执行初始化语句1
2. 执行条件判断语句2，看其结果是true还是false
如果是false，循环结束
如果是true，执行循环体语句3
3. 执行条件控制语句4
4. 回到步骤2继续执行

**注意事项：**

一般情况下，循环次数是确定的，我们会选择for循环，如果循环的次数无法确定，我们选择while循环实现功能。

while死循环：

```java
while(true){
	//循环体代码
}
```

```java
辗转相除法
a  b  c
// 25 10
while(b != 0){
	c = a % b; //5,0
	a = b;//10,5
	b = c;//5,0
}
gcd = a;
lcm = a * b / gcd;
```



### 2.6 do-while

**语法：**

初始化语句1;
do {
		循环体语句3;

​		条件控制语句4;
}while(条件判断语句2);

**执行流程：**

![image-20240912114152425](D:\video\zhongbei1\image\image-20240912114152425.png)

**注意事项：**

先执行语句体再判断，最少会执行一次。

死循环：

```java
do{
	//循环体语句
}while(true);
```

### 2.7 区别

1. for和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
   do...while先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）

2. 明确循环次数，推荐使用for
   不明确循环次数，推荐使用while
   do..while 很少使用

3. 死循环

   ```java
   for(;;){}
   while(true) {}
   do{}while(true);
   ```

## 3 循环嵌套

在一个循环内部可以嵌套另一个或多个循环。
外部循环每执行1次，内层循环会执行1轮(全部)。

## 4 label

代码中出现多层循环嵌套，label标签配合break、continue关键字，可以使程序从内部循环中跳出。

使用 label标签给循环起名字，然后使用break或continue加上label标签名即可。

## 5 Random

 java.util.Random ，是Java提供好的API，它提供了产生随机数的功能。

使用步骤如下：
1. 导包 : import java.util.Random;

2. 创建对象 : Random r = new Random();

3. 获取随机数 : 

  int num = r.nextInt(n); //其中num的取值为[0,n)
  注意：获取[min,max]范围随机数的公式如下
  int num = r.nextInt(max-min+1) + min;



## 6 方法

方法(method)：就是完成特定功能的代码块！
通过方法的定义和调用，可大大提高代码的复用性与可读性！

### 6.1 定义

方法定义语法：

`修饰符 返回值类型 方法名(形式参数列表) {
		方法体语句;
}`

### 6.2 调用

方法调用格式：
`方法名(实际参数列表);`

注意事项：

- 方法必须先定义，再调用
- 实际参数列表可以是常量，也可以是变量，也可以是表达式
- 实际参数类型要匹配形式参数类型（要么完全相同，要么能自动隐式类型转换）
- main方法是入口方法，一个程序中唯一，其可以调用其他普通方法
- 其他方法不能调用main方法，普通方法可以相互调用

**传值调用：方法的调用过程中，实参传递的仅仅是其值，而根本没有涉及到实参的内存区域！**

### 6.3 重载

方法重载要求：

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数列表不相同（类型不同或者数量不同）
- 重载跟方法的返回值类型无关

方法重载可以提高代码的可读性、简化方法调用、减少命名冲突、提高代码的复用性和提供灵活性。



# 第四章 数组

## 1 数组概述

数组，表示一块连续的内存空间，可用来存储多个数据(元素)，要求元素类型要一致。

## 2 数组定义

语法：

- 数据类型[] 数组名； （推荐用法）
- 数据类型 数组名[]；

注意事项：

- 数组是引用数据类型，用来存储一个引用值(可理解为地址值)
- 数组没有进行初始化，不可以直接使用

## 3 数组初始化

### 3.1 动态初始化

语法：
`数据类型[] 数组名 = new 数据类型[数组长度];`

注意事项：

- new 是一个关键字，表示为数组开辟内存空间
- 等号两边的数据类型要一致（先记住，后期会补充不一致的情况）
- 数组长度必须要有，可以>=0（一般大于0），但不能为负数

### 3.2 内存构成

```java
int[] arr = new int[4];
```

数组名标识的那块内存(栈空间)，存放了一个引用值(地址值)，通过该地址值可以找到堆空间相应内存（用来存放数组中所有元素）。

堆空间内存存在默认初始化：整形数初始化为0，浮点数0.0，引用类型null，字符类型初始化\u0000

### 3.3 数组下标

数组的下标的区间为 [0, 数组长度-1] 。

### 3.4 数组长度

数组长度，是指在一个数组中，可以存放同一类型元素的最大数量。
获取数组长度： `数组名.length`

注意事项：

- 数组长度必须在创建数组对象的时候就明确指定
- 数组长度一旦确定，就无法再改变
- 数组长度可以>=0（一般大于0），但不能为负数

### 3.5 数组默认值

数组在创建时，会开辟2块内存，数组名对应栈空间那块内存，数组元素会存放在堆空间。

堆空间数组每一个元素位置上，存在相应的默认值，要么为0，要么为0.0，要么为null。

### 3.6 静态初始化

在创建数组的同时，直接初始化数组元素的值，称为数组的静态初始化。

静态初始化格式：

- `数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};`
- `数据类型[] 数组名 = {元素1,元素2,...};`

错误写法：

![image-20240913112659892](D:\video\zhongbei1\image\image-20240913112659892.png)

## 4 数组异常

索引越界： ArrayIndexOutOfBoundsException，将错误的索引修改为正确的索引范围即可！

空指针：NullPointerException，给数组一个真正的堆内存空间引用即可！

## 5 工具类

java.util.Arrays 类，是JavaSE API中提供给我们使用的一个工具类，这个类中包含了操作数组的常用方法，比如排序、查询、复制、填充数据等，借助它我们在代码中操作数组会更方便。

## 6 综合案例

掌握冒泡排序、二分查找，自己能手写实现代码。

## 7 数组拷贝

数组的长度确定后便不能修改，如果需要数组存放更多元素，可以通过创建长度更长的新数组，然后先复制老数组内容到新数组中，再往新数组中放入额外的元素。

java.lang.System 类中提供一个名为 arraycopy 的方法可以实现复制数组中元素。

```java
public static void arraycopy(
    		  Object src,
              int srcPos,
              Object dest,
              int destPos,
              int length)
//参数1,需要被复制的源数组
//参数2,从源数组的哪一个位置开始复制
//参数3,需要把源数据复制到另外一个目标数组中
//参数4,把数据复制到目标数组的时候，从目标数组什么位置开始存储
//参数5,复制的源数组的长度
```

## 8 可变参数列表

语法：

`修饰符 返回值类型 方法名(数据类型... 参数名) {
		方法体语句;
}`

可变参数列表本质上是一个数组。

注意：

- 可变参数列表可以接受 0-n个参数

- 可变参数列表可以接受数组
- 方法中有一个可变参数，还可以同时存在其他参数
- 可变参数列表必须放在函数参数列表的最右端，且只能出现1次

## 9 foreach循环

增强for循环，简化数组（或集合）遍历操作。

语法：

`for (数据类型 变量 : 数组名){}`



## 10 二维数组

### 10.1 定义格式

`数据类型[][] 数组名 = new 数据类型[一维长度m][二维长度n];`

`数据类型[][] 数组名 = new 数据类型[一维长度][];`

### 10.2 内存结构

可以把二维数组看成一个一维数组，数组的每个元素对应的内存区域中，存放的是一维数组引用值。

### 10.3 元素访问

二维数组中元素的访问和赋值，也是通过数组下标实现。

`二维数组名[一维下标m][二维下标n];`

下表的访问范围：` [0，length-1]`

### 10.4 静态初始化

`数据类型[][] 数组名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...}, ...};`

`数据类型[][] 数组名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};`



# 第五章 面向对象基础

## 1 面向对象

OOP（object oriented programming），面向对象编程

- 是一种以对象为中心的编程思想，通过借助对象实现具体的功能
- 将大问题拆分成小问题，然后借助不同对象分别解决，最终实现功能

面向对象开发：

- 就是不断创建对象，使用对象，指挥对象做事情实现功能
- 原则：如果有对象，就指挥对象实现功能；如果没有，就创建对象，然后再指挥

面向对象语言三大特性：

- 封装（encapsulation） 信息隐蔽
- 继承（inheritance） 代码重用
- 多态（polymorphism） 灵活、接口统一

## 2 对象理解

万物皆对象。

理解对象：

- 任何事物都是一个对象（object）
- 每个对象都有自己的属性（静态的描述信息）、行为（动态的功能描述）
- 具有相似属性和行为的对象可以归为一类

## 3 类的定义

具有相同属性和行为的对象可以抽象为类（数据类型的一种）。

类的组成：

- 属性：指事物的特征，静态描述，例如：手机有品牌，价格，尺寸
- 行为：指事物所具有的功能，动态描述，例如：手机可以打电话，也可以发短信

结论：类是对象的抽象，对象是类的实例。

类定义语法：

```java
[public] class 类名 {
  //属性，可以包含0或多个
 [权限修饰符] 数据类型 成员变量名;
  //行为，可以包含0或多个
 [权限修饰符] 返回值类型 成员方法名(形参列表) {
    具体功能实现
 }
   
  //构造器，可有可无，暂时不用写，后续章节讨论
 [权限修饰符] 类名(形参列表) {
    初始化语句
 }
}
```

类定义步骤：

- 定义类
- 编写类的成员变量
- 编写类的成员方法

类的使用：

- 如Student是一种数据类型，是自定义类类型，属于引用类型
- 类类型使用时跟int、double等类型类似，都必须先定义变量并赋值，才能使用

## 4 对象使用

创建对象：`类名 对象名 = new 类名();`

调用成员：

- `对象名.成员变量`

- `对象名.成员方法()`

类和对象的关系：

- 类是对一类事物的描述，是抽象的
- 对象是一类事物的实例，是具体的
- 类是对象的模板，对象是类的实体

结论：类是一种抽象的数据描述，对象是类的一个具体的实例。

## 5 对象内存

系统会为每个对象开辟单独的内存空间（堆空间），用来存储对象的属性。

类的成员方法存储在方法区，只保留一份，只要是该类的对象，都可以调用。

## 6 变量对比

成员、局部变量区别：

- 定义位置不同
  成员变量：类中方法外
  局部变量：方法内部或方法声明上（形参列表）
- 内存中位置不同
  成员变量：堆内存
  局部变量：栈内存
- 生命周期不同
  成员变量：随着对象的存在而存在，随着对象的消失而消失
  局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
- 初始化值不同
  成员变量：有默认初始化值
  局部变量：没有默认初始化值，必须先定义、赋值才能使用

## 7 封装特性

### 7.1 概念理解

封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

封装的好处：

- 通过方法来控制成员变量的操作，提高了代码的安全性
- 代码用方法进行封装，提高了代码的复用性
- 隐藏代码实现细节，提供公共访问方式，简化操作

封装原则：

- 把不需要对外提供的内容隐藏起来
- 把属性隐藏，提供公共方法对其访问

### 7.2 private

private表示私有，用它修饰类的成员（含成员变量、成员方法），则这些成员只能在类内（类的成员方法内部）去使用，其他地方不可以操作；

public表示公有，用它修饰类的成员（含成员变量、成员方法），则这些成员在类内、类外都都可以操作。

### 7.3 封装实现

封装步骤：
1. 使用private修饰成员变量
2. 提供对应的setXxx()、getXxx()方法，用pubic修饰
3. 具体使用时，借助对象的setXxx方法给属性赋值，getXxx方法获取属性值

getter()、setter()操作

bean、pojo(Plain Old Java Object)

## 8 this关键字

在类中的普通成员方法中，可以使用this关键字。其表示调用当前方法的对象引用，即哪个对象调用该方法，this就代表哪一个对象。

this关键字用法：

- 对成员变量和局部变量进行区分
  固定格式： this.数据成员;

- 调用类中的成员方法
  固定格式： this.成员方法(实际参数列表);
- 调用类中的其他构造器（后面章节补充）

结论：成员方法被哪个对象调用，方法中的this就代表那个对象，即谁调用，this就代表谁。

## 9 构造方法

构造方法可以对对象进行初始化操作，即为对象开辟内存空间的同时，给对象的成员赋初值。

构造方法定义及调用：
//固定定义格式
`[修饰符] 类名(参数列表) {
  初始化语句s;
}`
//构造方法调用格式，实参列表可以为空
`类名 对象 = new 类名(实参列表);`

注意事项：

- 构造方法一般使用 public 修饰
- 构造方法没有返回值类型，连 void 都没有
- 构造方法名和类名相同（区分大小写）
- 构造方法可以重载

执行时机 ：

- 创建对象的时候会被自动调用，每创建一个对象，就会执行一次构造方法
- 不要，也不能手动调用构造方法

默认构造方法：

- 用户不定义构造方法，则系统会提供一个无参构造方法
- 用户定义构造方法，则系统不再提供无参构造方法

对象创建步骤：（了解）

```java
public static void main(String[] args) {
	Student s = new Student("zhang",23);
}

1. 将Student.class文件加载到内存方法区
2. 在main栈帧中开辟一块内存，用s标识（定义s变量）
3. 在堆中开辟内存（new 对象）
4. 对堆空间的属性进行默认初始值（null，0）
5. 对属性进行显式初始化（如果存在的话，如 private int age = 10;）
6. 调用构造方法，用（"zhang"，23）给属性赋值
7. 将堆中对象的内存地址赋值给s内存，对象创建完成
```

## 10 this补充

在构造方法中，可以借助this关键字调用其他构造方法。
具体格式为： `this(实际参数列表);`

注意： this(实际参数列表) 必须是构造方法中的第一行有效代码。



# 第六章 static、继承、重写、多态

## 1 static

### 1.1 问题引入

多个学校共用一个图书馆，图书馆有且只有一个，只占用一块内存区域，使用static关键字修饰图书馆变量。

### 1.2 静态成员

static修饰类中的数据成员，该成员就成了静态数据成员，也称为类成员。

类成员，是属于类的，被这个类的所有对象共享，只占用一块内存空间。

定义及访问格式：
`[public] class 类 {
  //定义格式
  权限修饰符 static 数据类型 变量名;
  //其他省略...
}`
//访问格式
`类名.static成员;`

static成员特点：

- 被类的所有对象共享
- 随着类的加载而加载，先于对象存在
- 可以通过类名调用，也可以通过对象名调用，推荐使用类名调用
- 方法区中有一块专门的区域：静态区，专门用来存储类的static成员

静态数据成员初始化：

- 静态数据成员随着类加载而加载（开辟相应内存），并会进行默认初始化，
  默认初始化值为 null(引用类型)、0(整形)、0.0(浮点型)、false(布尔类型) 。

- 对静态数据成员的初始化，一般采用两种方式：

  显式初始化、静态代码块初始化（后面章节介绍）
  显式初始化格式：` [修饰符] static 数据类型 静态成员名 = 初始值;`

- 不要在构造方法中对static成员进行初始化，因为只要创建对象，构造方法就会自动被执行，导致static成员值不经意间被修改。

### 1.3 静态方法

在类中，使用static修饰的方法，就是静态方法；
static方法的作用，主要是用来操作static成员；
static方法可以使用类名来调用，也可以使用对象名来调用，但推荐使用类名。

static方法和普通成员方法区别：

- 静态方法只能访问静态的成员
- 成员方法可以访问静态的成员，也可以访问非静态的成员
- 静态方法中没有this关键字 （本质区别）

### 1.4 代码块

在Java中，使用 { } 括起来的代码被称为代码块，可以分为三类：

- 局部代码块

  位置：类的方法中定义
  格式： { 语句体; }
  作用：用于限定变量的生命周期，使其尽早释放，从而提高栈
  空间内存利用率
  重要程度：了解，使用不多

- 构造代码块

  位置：类中方法外
  格式： { 语句体; }
  特点：每次构造方法执行前，都会先执行该代码块中代码
  作用：如果多个构造方法中出现相同代码，可以抽取到构造代码块中，从而提高代码复用性
  重要程度：掌握

- 静态代码块

  位置：类中方法外
  格式： static { 语句体; }
  特点：随着类的加载而加载，只执行一次
  作用：类加载时做一些数据的初始化操作（一般给static成员赋值）
  重要程度：掌握

  结论：显式初始化和静态代码块，谁在上面，谁先执行

### 1.5 类加载时机

加载类的含义：JVM虚拟机将该类的class文件加载到内存的方法区中。
先加载main()方法所在类，然后在执行main()方法过程中，第一次遇到没有被加载的类，就会加载该类。

### 1.6 对象创建过程

```java
public static void main(String[] args) {
	School s = new School("一中",3000);
}
```

- 对 School 类进行类加载
- 去方法区中的静态区为 School.library 分配内存空间，并做默认初始化（值为 null ）
- 对 School.library 进行显式初始化，执行 School 类中的静态代码块
  注意：谁在前面则谁先执行
- 在栈空间（main方法函数帧）开辟一块内存，用 s(引用变量) 标识
- 堆区中分配对象的内存空间，同时进行默认初始化
- 对 School 中的属性进行显式初始化
  例如： public int num = 2000;
- 执行 School 类的构造代码块
- 执行 School 类的构造方法
- 把对象堆空间的内存地址赋给变量s（写入s那块内存区域中）
  

### 1.7 静态导入

在自定义类中，要使用另一个类中的静态属性和静态方法，可以使用静态导入。

导入完成后，可以直接使用这个类中的静态属性和静态方法，而不用在前面加上类名。

静态导入格式：
导入静态成员： `import static 类的全包名.static数据成员名;`
导入静态方法：` import static 类的全包名.static成员方法名;`

静态导入目的：简化编程。

### 1.8 单例模式

单例模式目的是使类只能实例化一个对象。

饿汉式：类加载时就直接实例化对象。

懒汉式：第一次使用时实例化对象。

编程步骤：

```java
// 1.构造器私有
private Singleton(){}

// 2.提供private static变量存储唯一的对象
private static Singleton instance;

// 3.提供public static 方法获取唯一对象
public static Singleton getInstance(){...}
```



## 2 继承

### 2.1 概念理解

继承关系体现的是一种 "is a" 的关系

### 2.2 继承实现

子类继承父类，使用 extends 关键字实现。

语法：

```java
[public] class 子类名 extends 父类名 {
	子类新增内容;
}
```

### 2.3 继承特点

- Java只支持单继承，不支持多继承

  一个类有且只有一个父类

- Java支持多层次继承

  子类A 继承 父类B ，父类B 继承 爷爷类C

### 2.4 继承细节

子类只能继承父类所有非私有的成员（含成员方法和成员变量）。

非专业描述：完全继承、有限访问

Java中的每个类都直接或间接继承Object类，Object类是Java继承
体系中的最顶层父类。

### 2.5 应用场景

多个类中存在相同属性和行为，且类和类之间具有 is a 的关系，就可以将公共的内容抽取到一个单独的父类中。

### 2.6 优缺点

优点：

- 提高代码的复用性
- 提高了代码的维护性（父类修改后，子类全部生效）
- 让类与类之间产生了 is a 的关系，是多态的前提

## 3 super

super表示子类对象中从父类继承的那部分（可看成一个父类对象的引用）！

使用语法：

`super.数据成员 `，表示访问从父类继承的数据成员
`super.成员方法(实参列表)` ，表示调用从父类继承的成员方法

在子类方法中访问变量，会遵循就近原则，具体如下：
1. 先在子类局部范围中查找局部变量
2. 再在子类中查找新增的成员变量
3. 最后从父类继承的成员变量中查找

## 4 构造方法

子类对象的数据成员包含两部分：继承部分，新增部分

- 对新增部分数据成员初始化，子类构造方法中直接 `this.新增数据成员 = 值; `即可
- 对继承部分数据成员初始化，子类构造方法中通过super关键字调用父类构造方法
  格式： `super(实际参数列表);`

注意：

- 如果子类构造方法中没有显式通过 super 调用父类构造方法，则系统会默认调用 super()
- 如果子类构造方法中需要调用父类有参构造方法，必须手动调用super(实参...)
- 子类构造方法中如果显式调用super(实参列表)，则该代码必须为第一行有效代码

## 5 访问控制

类中的属性和方法，可以使用以下四种权限修饰符进行访问控制：

public > protected > default > private

![image-20240920151453668](D:\video\zhongbei1\image\image-20240920151453668.png)

## 6 方法重写

方法重写要求：

- 前提：父子类继承关系中
- 子类和父类方法名相同、形参列表相同、返回类型一般相同
- 访问权限修饰符可以被扩大，但不能被缩小
  public > protected > default > private
- 方法抛出异常类型的范围可以被缩小，但不能被扩大

> 方法重载要求：
>
> - 多个方法在同一个类中
> - 多个方法具有相同的方法名
> - 多个方法的参数列表不相同（类型不同或者数量不同）
> - 重载跟方法的返回值类型无关

注意：一般情况下，子类进行方法重写时，最好方法声明完全一致

**结论：子类继承父类，在调用方法的时候，如果子类中没有重写，那么调用从父类继承的方法，如果子类重写了这个方法，那么调用子类重写的方法。**

特殊情况：

- 父类中的静态方法（属于类方法）不能被子类重写
  static静态方法算不上重写，它属于父类所独有，只是书写格式上跟重写相似
- 父类中的私有方法（未被继承）不能被子类重写

重写java.lang.Object.toString()：当输出对象时，会先执行对象.toString() 获得对象的字符串形式，然后输出该字符串！

## 7 final

- final修饰类
  类不能被继承
- final修饰方法
  方法不能被重写
- final修饰变量
  变量就成了常量，初始化以后其值不能改变；
  - final修饰局部变量
    则局部变量赋初值后，不能再次赋值，否则编译报错！
  - final修饰成员变量，初始化可采用下面3种方式：
    - 显式初始化
    - 构造代码块中初始化
    - 构造方法中初始化
      注意：如果使用构造方法对final成员初始化，则类中所有构造方法都要对final成员进行初始化，否则编译报错！
  - final修饰静态变量，初始化方式有2种：
    - 显式初始化：声明的同时赋值
    - 静态代码块中赋值
- final修饰引用类型变量，则该变量的引用值不能改变，但引用内存空间中的内容是可以改变的。

## 8 多态

一种事物，多种形态。

Java多态理解： `引用变量.方法(实参列表); `完全相同的这行代码，出现在不同的位置，其执行的结果是不同的。

多态要求（条件）：

- 子类继承父类
- 子类重写父类中的方法
- 父类的引用指向子类对象
- 用父类引用调用重写方法

多态优缺点：

- 优点：提高程序的扩展性、灵活性

- 缺点：不能使用子类的特有成员



class DB{

​		...

​		需要重写的方法

​		method1(){...}

}



class MySQLDB extends DB{

  // 重写父类方法

​	method1(){...}

}



使用：

{

​			DB db = 创建对象 MySQLDB (); --->从文件中读取数据库名

​			db.method1()

}

## 9 引用类型转换

- 向上转型（隐式转换）

前提：使用父类引用指向子类对象，然后通过父类引用访问成员变量或成员方法
操作成员变量：编译看左边 (父类)，运行看左边 (父类)
操作成员方法：编译看左边 (父类)，运行看右边 (子类)

- 向下转型（显式转换）

必须先有向上转型，才能向下转型

向上转型（多态）时，父类引用无法调用到子类中独有的成员变量和成员方法！

- instanceof

在类型强制转换的过程中，可能会遇到类型转换异常ClassCastException，为了避免此异常，可以使用instanceof。

语法：`引用名 instanceof 类型名`

作用：判断引用名实际指向的对象，其所属类型是否为右边的类型，返回true或false。



# 第七章 抽象、接口、内部类、枚举

## 1 abstract

### 1.2 抽象概述

抽象是一种关注问题的本质和关键特征，而忽略具体实现细节的方法。

抽象方法：只有方法声明，没有方法体。

抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。

### 1.3 抽象特点

定义语法：

```java
//抽象类定义格式
[权限修饰符] abstract class 类名 {
	//抽象方法定义格式
	[权限修饰符] abstract 返回值类型 方法名(参数列表);
	//特别注意：抽象方法只有方法声明，没有方法的实现
}
```

**抽象类和抽象方法的关系：**

- 使用abstract修饰的类就是抽象类
- 抽象类可以包含，也可以不包含抽象方法
- 包含抽象方法的类，一定要声明为抽象类

**抽象类和普通类区别**：

- 抽象类必须使用abstract修饰符
- 抽象类多了包含抽象方法的能力
- 抽象类失去了实例化创建对象的能力

**抽象类和普通类相同点**：

- 符合继承关系特点，能够使用多态机制
- 子类可以重写从抽象类继承的方法
- 实例化子类对象需要借助父类构造器实现父类部分的初始化

注意：子类继承抽象类，如果没有重写所有的抽象方法，则子类也是抽象类

## 2 interface

### 2.1 接口概述

接口定义语法：

```java
[修饰符] interface 接口名 {
	//数据成员，可以定义多个
	[public static final] 数据类型 数据成员 = 值;
 	//抽象方法：可以定义多个
	[public abstract] 返回值类型 方法名(形参列表);
}
```

- 定义类使用关键字 class ，定义接口使用关键字 interface
- 接口中的数据成员，默认 public static final 修饰，是常量，一般名称全大写
- 接口中的方法，默认 public abstract 修饰，是抽象方法

### 2.2 接口实现

接口实现语法：

```java
//一个类可以同时实现多个接口
[修饰符] class 类名 implements 接口名1,接口名2,... {
	重写所有抽象方法
}
```

注意事项：

- 接口属于引用数据类型的一种，它不是类，没有构造方法
- 接口的实现类（子类），可以是正常类（重写所有抽象方法），也可以是抽象类（包含抽象方法）
- 接口不能创建对象，一般用接口引用指向实现类对象
- 在类和接口的实现关系中，可以使用多态 ，因为类和接口的实现关系，可以理解为继承的一种形式。

### 2.3 接口继承

- 类和类之间是单继承关系，使用extends
- 类和接口之间是多实现关系，使用implements
- 接口和接口之间是多继承关系，使用extends

接口继承语法：

```java
[修饰符] interface 子接口 extends 父接口1,父接口2... {
	//新增成员或抽象方法
}
```

### 2.4 综合案例

复杂实现类定义语法：

```java
[修饰符] class 实现类 extends 父类 implements 接口名1, 接口名2, ... { 
	重写所有方法;
}
```

注意：接口多态应用时，编译看左边，运行看右边。即接口引用只能调用接口中包含的方法，成功调用的是重写以后的方法。

### 2.5 类接口关系

- 类与类的关系
  继承关系，只能单继承，但是可以多层继承
- 类与接口的关系
  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
- 接口与接口的关系
  继承关系，可以单继承，也可以多继承

### 2.6 接口新特性（了解）

JDK8新特性：接口可以包含静态方法和默认方法

JDK9新特性：接口可以包含私有方法

### 2.7 常见面试题

接口和抽象类有什么区别？如何选择？

- 语法区别：
  - 定义方式：抽象类通过使用 abstract class来定义，而接口使用 interface 来定义
  - 数据成员：抽象类可以包含普通数据成员和static数据成员，而接口只能包含 static final 修饰的数据成员
  - 成员方法：抽象类可以包含具体的方法实现，而接口只能包含抽象方法(JDK8前)
  - 构造函数：抽象类可以有构造函数，而接口不能有构造函数
  - 实现方式：一个类可以继承（extends）一个抽象类，而一个类可以实现（implements）多个接口

- 设计理念区别：
  - 同一个接口的不同的实现类之间，体现的是  like a 的关系 
  - 子类和抽象父类体现的是 is a 的关系
- 结论：
  - 如果仅仅要额外扩展已存在类的功能，则选择定义接口，让类去实现接口；
  - 如果需要创建一组相关的类，且这些类之间有一些共同的行为和属性，那么可以定义一个类作为这些类的父类。如果不想实例化父类对象，可以把这个父类设置为抽象类。

项目功能分工

模块1

​	定义接口{

​			// 定义规范（方法名、参数列表、返回值类型）

​			method1声明;

​			...

​			method10声明;

​	}

​	接口实现 implements 接口{

​			...

​	}

​	

模块2

。。。



项目功能组合：

main{

​		用到功能1

​		接口1 变量1 = get接口1实现(); // new() --> 反射

​		变量1.method1(); // 多态

}

## 3 内部类

在一个类的内部再定义另外的一个类，这就是内部类。

内部类一共分为四种：

- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

### 3.1 成员内部类

定义语法：

```java
//外部类
[修饰符] class 外部类 {
  //省略...
   
  //内部类
 [权限修饰符] class 内部类 {
    0或多个数据成员
    0或多个构造方法
    0或多个成员方法
    //注意，不可以包含static成员或方法
 }
}
```

内部类对象实例化语法：`外部类名.内部类名 对象名 = new 外部类().new 内部类();`

内部类中访问外部类中同名成员：`外部类名.this.成员名`

注意事项：

- 成员内部类中可以直接访问外部类中所有成员和方法（含private）
- 在外部类中可以直接访问内部类所有的成员和方法（含private），但必须借助内部类对象
- 成员内部类内部不能定义static成员或方法

什么情况下会使用内部类？

在对事物进行抽象的时候，如果一个事物内部还包含其他事物，就可以考虑使用内部类这种结构。如汽车（Car）中包含发动机（Engine）。

### 3.2 静态内部类

定义语法：

```java
//外部类
[修饰符] class 外部类 {
  //省略...
  
  //静态内部类
 [权限修饰符] static class 内部类 {
    0或多个数据成员
    0或多个构造方法
    0或多个成员方法
   
    //注意：静态内部类成员方法内，只能访问外部类static成员或方法
 }
}
```

对象定义语法：`外部类.内部类 对象 = new 外部类.内部类(实参列表);`

内部类中静态方法访问语法：`外部类名.内部类名.方法名();`

注意事项：

- 相对于成员内部类，静态内部类中可以定义static成员和方法
- 静态内部类成员方法内，只能访问外部类static成员或方法【静态只能访问静态】
- 外部类方法可以访问静态内部类所有成员及方法

### 3.3 局部内部类（了解）

在外部类方法中定义的内部类，称为局部内部类，其作用范围只是在当前方法中。

定义语法：

```java
[修饰符] class 外部类 {
  //省略...
 
  //成员方法
 [修饰符] 返回值类型 方法名(形式参数列表) {
//功能实现省略...
   
    //局部内部类定义
    class 成员内部类名 {
      0或多个数据成员
      0或多个构造方法
      0或多个成员方法
   }
	//注意：局部内部类的作用范围在当前方法中，只能在该方法中使用
  }
 }
```

注意事项：

- 局部内部类只能在定义的方法中使用
- 在局部内部类方法中操作它外部方法定义的局部变量，则该局部变量默认为final修饰

### 3.4 匿名内部类（重要）

是一种没有名字的内部类，本质上是一个特殊的局部内部类（定义在方法内部）。

定义语法：

```java
父类或接口类型 变量名 = new 父类或接口(构造方法实参列表) {
  // 重写所有的抽象方法
    
    @Override
  public 返回值类型 method1(形参列表) {
 	方法体实现
 }
 
  @Override
  public 返回值类型 method2(形参列表) {
 	方法体实现
 }
 
  //省略...
};

//匿名内部类对象调用方法
变量名.重写方法(实参列表);
```

匿名内部类的俩种形式：

- 利用父类，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个父类的子类型
- 利用接口，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个接口的实现类

匿名内部类注意事项：

- 匿名内部类必须依托于一个接口或一个父类（可以是抽象类，也可以是普通类）
- 匿名内部类在声明的同时，就必须创建出对象，否则后面就没法创建了
- 匿名内部类中无法定义构造器

内部类应用场景选择：

- 考虑这个内部类，是否需要反复的进行使用（必须有名字）
  在这个内部类中，如果需要定义静态的属性和方法，选择使用静态内部类
  在这个内部类中，如果需要访问外部类的非静态属性和方法，选择使用成员内部类
- 考虑这个内部类，如果只需要使用一次（可以没有名字）
  选择使用匿名内部类
- 局部内部类，几乎不会使用

## 4 包装类

### 4.1 概述

![image-20240924112511429](D:\video\zhongbei1\image\image-20240924112511429.png)

### 4.2 基础案例

- int --> Integer

  new Integer(int);

  Integer.valueOf(int);

- Integer --> int

  intValue()

- String --> int

  Integer.parseInt(String)

### 4.3 自动装箱拆箱

JDK1.5或以上，可以支持基本类型和包装类型之间的自动装箱、
自动拆箱，这简化了基本类型和包装类型之间的转换。
自动装箱：基本数据类型值 自动转化为 包装类对象
自动拆箱：包装类对象 自动转化为 基本数据类型值

注意事项：

- 不同类型的基本数据类型和包装类，是不可以自动装箱拆箱的，例如int和Long
- 给Byte Short Character赋值时，支持整形常量优化机制

### 4.4 Integer缓冲区

在Java中方法区有一个叫做运行时常量池（Runtime ConstantPool）的区域，用于存储编译期间生成的各种字面常量和符号引用，Integer常量池就存储在该区域。

Integer常量池是一个特殊的缓存机制，用于存储在范围 [-128,127] 之间的Integer常量对象。

System 类方法：
`public static native int identityHashCode(Object x);`
会返回对象的哈希码，即Java根据对象在内存中的地址计算出来一个整数值

结论：相同地址的对象调用该方法结果相同，不同地址对象结果不同

## 5 Object类

### 5.1 toString

该方法前面课程已经讲过，其可以返回一个对象默认的字符串形式。

### 5.2 equals

该方法用于比较2个对象是否相等。

结论：Object中的equals方法，直接使用==进行比较，比较俩个对象地址值是否相等！

### 5.3 hashCode

JVM根据对象在内存的中的特征（地址值），通过哈希算法计算产生一个哈希值。

注意：

- 俩个引用变量指向同一个对象，则它们的hashCode值一定相等
- 俩个引用变量的hashCode值相同，则它们有可能指向同一个对象，也可能指向不同对
- 俩个引用变量的hashCode值不同，则它们肯定不可能指向同一个对象

### 5.4 getClass

返回引用变量在运行时所指向的字节码对象。

## 6 String类

用双引号括起来的字符串，其类型 java.lang.String。

### 6.1 概述

String基础：

- String 类在 java.lang 包下，所以使用的时候不需要导包
- Java 程序中所有字符串字面值（如"abc"）都是 String类对象
- 字符串值不可变： String 对象是不可变的，一旦创建，它们的值就不能被修改

常用字符串构建方法：

![image-20240925092113412](D:\video\zhongbei1\image\image-20240925092113412.png)

### 6.2 常见方法

```java
  //获取字符串字符个数
  public int length();
 
  //比较字符串的内容不要用==，严格区分大小写
  public boolean equals(Object anObject);
 
  //返回指定索引处的 char 值
  public char charAt(int index);

  //将字符串拆分为字符数组后返回
  public char[] toCharArray();
 
  //根据传入的规则切割字符串，得到字符串数组
  public String[] split(String regex);
 
  //根据开始和结束索引进行截取，得到新的字符串 [begin,end)
  public String substring(int begin, int end);
 
  //从传入的索引处截取，截取到末尾，得到新的字符串[begin,str.length())
  public String substring(int begin);
 
  //使用新值，将字符串中的旧值替换，得到新的字符串
  public String replace(CharSequence target,CharSequence replacement);
}
```

### 6.3 常量池

String常量池是一块特殊的内存区域，用于存储字符串常量，设计目的是为了节省内存和提高性能。

当我们创建字符串常量时，如果字符串常量池中已经存在相同内容的字符串，那么新创建的字符串常量会直接引用已存在的字符串对象，而不会创建新的对象。

Java将字符串放入String常量池的方式：

- 直接赋值
  例： String str = "Hello"; 
- 使用new关键字创建对象
  例： String str = new String("World");
- 3. 调用String类提供intern()方法

编译期优化：

使用 + 拼接多个字符串常量，拼接的结果仍旧是字符串常量
如果结果字符串常量在常量池中不存在，则会将其放入字符串常量池中

## 7 枚举

### 7.1 枚举类概述

枚举是JDK1.5引入的新特性，可以通过关键字 enum 来定义枚举类，枚举类型对象取值是定义时固定的几个值。

注意事项：

- 枚举类本质上是一个final修饰的类，不可以被继承
- 枚举类会默认继承 java.lang.Enum 这个抽象泛型类
- 枚举元素，本质上是枚举类对象，由 static和final 修饰
- 枚举类构造器私有，在类外不能主动创建枚举类对象
- 枚举类中可以包含 public static 静态方法

### 7.2 基本方式定义

语法：

```java
[修饰符] enum 枚举类名 {
	枚举元素1,枚举元素2,...枚举元素n;
}
```

### 7.3 构造方法定义（了解）

包含成员变量、成员方法、构造方法的枚举类。

语法：

```java
[修饰符] enum 枚举类名 {
枚举元素1(实际参数列表),...,枚举元素n(实际参数列表);
    
  //枚举类数据成员和成员方法，可以包含多个
 [修饰符] 数据类型 数据成员名;
 
 [修饰符] 返回值类型 成员方法名(形参列表) {
 	方法体实现;
 }
 
  //枚举类构造方法，可以包含多个必须使用private进行修饰
  private 构造方法;
}
```

注意：枚举类构造方法，如果不提供，系统会提供默认构造方法，无参、private修饰。如果用户自定义枚举类构造方法，则系统不再提供默认构造方法。

### 7.4 抽象方法定义（了解）

包含抽象方法的枚举类。

语法：

```java
[修饰符] enum 枚举类名 {
枚举元素1(实参列表) {
    重写所有抽象方法;
 }, ...枚举元素n(实参列表) {
    重写所有抽象方法;
 };
 
  //可以包含多个抽象方法
  抽象方法声明;
 
  //数据成员、成员方法及构造方法省略...
}
```



# 第八章 集合

## 1 集合概述

在Java中，集合（Collection）是一种用于存储和操作一组对象的数据结构。由一组类和接口组成，放在java.util包下。

集合框架的主要目标是提供一种通用的方式来存储和操作对象的集合。

集合和数组都可以存储多个元素值，对比数组，我们来理解下集合：

- 数组的长度是固定的，集合的长度是可变的
- 数组中存储的是同一类型的元素，集合中存储的数据可以是不同类型的
- 数组中可以存放基本类型数据或者引用类型数据，集合中只能存放引用类型数据
- 数组除了 length属性 ，还有从Object中继承过来的方法之外，就调用不到其他属性和方法了
- 集合框架由 java.util 包下多个接口和实现类组成，定义并实现了很多方法，功能强大

## 2 框架体系

集合框架主要有三个要素组成：

- 接口
  整个集合框架的上层结构，都是用接口进行组织的，接口中定义了集合中必须要有的基本方法。

- 实现类
  对于上层使用接口划分好的集合种类，每种集合的接口都会有对应的实现类。

- 数据结构

  不同的实现类，它们存储、操作数据的方式不同，也就是使用的数据结构不同。

集合分类：

- 单列集合（Single Column Collection）
  根接口： java.util.Collection
  单列集合是指每个集合元素只包含一个单独的对象（单值）
- 多列集合（Multiple Column Collection）
  根接口： java.util.Map
  多列集合是指每个集合元素由多个列（字段）组成，可以同时存储和操作多个相关的值（键值对）

Collection接口结构图：

![image-20240925121212215](D:\video\zhongbei1\image\image-20240925121212215.png)



Map接口结构图：

![image-20240925121247809](D:\video\zhongbei1\image\image-20240925121247809.png)